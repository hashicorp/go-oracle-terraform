package compute

import (
	"fmt"
	"strings"
)

const WaitForInstanceReadyTimeout = 300
const WaitForInstanceDeleteTimeout = 600

// InstancesClient is a client for the Instance functions of the Compute API.
type InstancesClient struct {
	ResourceClient
}

// Instances obtains an InstancesClient which can be used to access to the
// Instance functions of the Compute API
func (c *Client) Instances() *InstancesClient {
	return &InstancesClient{
		ResourceClient: ResourceClient{
			Client:              c,
			ResourceDescription: "instance",
			ContainerPath:       "/launchplan/",
			ResourceRootPath:    "/instance",
		}}
}

// InstanceInfo represents the Compute API's view of the state of an instance.
type InstanceInfo struct {
	// TODO: add placement_requirements?

	// The ID for the instance. Set by the SDK based on the request - not the API.
	ID string

	// A dictionary of attributes to be made available to the instance.
	// A value with the key "userdata" will be made available in an EC2-compatible manner.
	Attributes map[string]interface{} `json:"attributes"`

	// Boot order list.
	BootOrder []int `json:"boot_order"`

	// The reason for the instance going to error state, if available.
	ErrorReason string `json:"error_reason"`

	// A label assigned by the user, specifically for defining inter-instance relationships.
	Label string `json:"label"`

	// Name of imagelist to be launched.
	ImageList string `json:"imagelist"`

	// IP address of the instance.
	IPAddress string `json:"ip"`

	// Name of this instance, generated by the server.
	Name string `json:"name"`

	// Mapping of to network specifiers for virtual NICs to be attached to this instance.
	Networking map[string]NetworkingInfo `json:"networking"`

	// Type of instance, as defined on site configuration.
	Shape string `json:"shape"`

	// ID's of SSH keys that will be exposed to the instance.
	SSHKeys []string `json:"sshkeys"`

	// TODO: make this a Constant
	// State of the instance.
	State string `json:"state"`

	// The Storage Attachment information.
	Storage []StorageAttachment `json:"storage_attachments"`

	// The OS platform for the instance.
	Platform string `json:"platform"`

	// vCable for this instance.
	VCableID string `json:"vcable_id"`
}

type StorageAttachment struct {
	// The index number for the volume.
	Index int `json:"index"`

	// The three-part name (/Compute-identity_domain/user/object) of the storage attachment.
	Name string `json:"name"`

	// The three-part name (/Compute-identity_domain/user/object) of the storage volume attached to the instance.
	StorageVolumeName string `json:"storage_volume_name"`
}

func (i *InstanceInfo) getInstanceName() string {
	return fmt.Sprintf(CMP_QUALIFIED_NAME, i.Name, i.ID)
}

type CreateInstanceInput struct {
	// TODO: add hostname/reverse_dns?

	// A dictionary of user-defined attributes to be made available to the instance.
	// Optional
	Attributes map[string]interface{} `json:"attributes"`
	// Boot order list
	// Optional
	BootOrder []int `json:"boot_order"`
	// Name of imagelist to be launched.
	// Optional
	ImageList string `json:"imagelist"`
	// A label assigned by the user, specifically for defining inter-instance relationships.
	// Optional
	Label string `json:"label"`
	// Name of this instance, generated by the server.
	// Optional
	Name string `json:"name"`
	// Networking information.
	// Optional
	Networking map[string]NetworkingInfo `json:"networking"`
	// Type of instance, as defined on site configuration.
	// Required
	Shape string `json:"shape"`
	// A list of the Storage Attachments you want to associate with the instance.
	// Optional
	Storage []StorageAttachmentInput `json:"storage_attachments"`
	// A list of the SSH public keys that you want to associate with the instance.
	// Optional
	SSHKeys []string `json:"sshkeys"`
}

type StorageAttachmentInput struct {
	// The index number for the volume. The allowed range is 1 to 10.
	// If you want to use a storage volume as the boot disk for an instance, you must specify the index number for that volume as 1.
	// The index determines the device name by which the volume is exposed to the instance.
	Index int `json:"index"`
	// The three-part name (/Compute-identity_domain/user/object) of the storage volume that you want to attach to the instance.
	// Note that volumes attached to an instance at launch time can't be detached.
	Volume string `json:"volume"`
}

const ReservationPrefix = "ipreservation"
const ReservationIPPrefix = "network/v1/ipreservation"

type NetworkingInfo struct {
	DNS           []string `json:"dns,omitempty"`
	IPAddress     string   `json:"ip,omitempty"`
	IPNetwork     string   `json:"ipnetwork,omitempty"`
	MACAddress    string   `json:"address,omitempty"`
	Model         string   `json:"model,omitempty"`
	NameServers   []string `json:"name_servers,omitempty"`
	Nat           []string `json:"nat,omitempty"`
	SearchDomains []string `json:"search_domains,omitempty"`
	SecLists      []string `json:"seclists,omitempty"`
	Vnic          string   `json:"vnic,omitempty"`
	VnicSets      []string `json:"vnicsets,omitempty"`
}

// LaunchPlan defines a launch plan, used to launch instances with the supplied InstanceSpec(s)
type LaunchPlanInput struct {
	// Describes an array of instances which should be launched
	Instances []CreateInstanceInput `json:"instances"`
}

type LaunchPlanResponse struct {
	// An array of instances which have been launched
	Instances []InstanceInfo `json:"instances"`
}

// LaunchInstance creates and submits a LaunchPlan to launch a new instance.
func (c *InstancesClient) CreateInstance(input *CreateInstanceInput) (*InstanceInfo, error) {
	qualifiedSSHKeys := []string{}
	for _, key := range input.SSHKeys {
		qualifiedSSHKeys = append(qualifiedSSHKeys, c.getQualifiedName(key))
	}

	input.SSHKeys = qualifiedSSHKeys

	qualifiedStorageAttachments := []StorageAttachmentInput{}
	for _, attachment := range input.Storage {
		qualifiedStorageAttachments = append(qualifiedStorageAttachments, StorageAttachmentInput{
			Index:  attachment.Index,
			Volume: c.getQualifiedName(attachment.Volume),
		})
	}
	input.Storage = qualifiedStorageAttachments

	input.Networking = c.qualifyNetworking(input.Networking)

	input.Name = fmt.Sprintf(CMP_QUALIFIED_NAME, c.getUserName(), input.Name)

	plan := LaunchPlanInput{Instances: []CreateInstanceInput{*input}}

	var responseBody LaunchPlanResponse
	if err := c.createResource(&plan, &responseBody); err != nil {
		return nil, err
	}

	if len(responseBody.Instances) == 0 {
		return nil, fmt.Errorf("No instance information returned: %#v", responseBody)
	}

	// Call wait for instance ready now, as creating the instance is an eventually consistent operation
	getInput := &GetInstanceInput{
		Name: input.Name,
		ID:   responseBody.Instances[0].ID,
	}

	result, err := c.WaitForInstanceRunning(getInput, WaitForInstanceReadyTimeout)
	if err != nil {
		return nil, err
	}

	// Unqualify instance name
	result.Name = input.Name

	// Unqualify ip network
	for k, v := range result.Networking {
		if v.IPNetwork != "" {
			v.IPNetwork = input.Networking[k].IPNetwork
		}
	}

	return result, nil
}

// Both of these fields are required. If they're not provided, things go wrong in
// incredibly amazing ways.
type GetInstanceInput struct {
	// The Unqualified Name of this Instance
	Name string
	// The Unqualified ID of this Instance
	ID string
}

func (g *GetInstanceInput) String() string {
	return fmt.Sprintf(CMP_QUALIFIED_NAME, g.Name, g.ID)
}

// GetInstance retrieves information about an instance.
func (c *InstancesClient) GetInstance(input *GetInstanceInput) (*InstanceInfo, error) {
	if input.ID == "" || input.Name == "" {
		return nil, fmt.Errorf("Both instance name and ID need to be specified")
	}

	var responseBody InstanceInfo
	if err := c.getResource(input.String(), &responseBody); err != nil {
		return nil, err
	}

	if responseBody.Name == "" {
		return nil, fmt.Errorf("Empty response body when requesting instance %s", input.Name)
	}

	// Overwrite returned name/ID with known name/ID
	// Otherwise the returned name will be the fully qualified name, and the ID will be blank
	responseBody.Name = input.Name
	responseBody.ID = input.ID

	c.unqualify(&responseBody.VCableID)

	// Unqualify SSH Key names
	sshKeyNames := []string{}
	for _, sshKeyRef := range responseBody.SSHKeys {
		sshKeyNames = append(sshKeyNames, c.getUnqualifiedName(sshKeyRef))
	}
	responseBody.SSHKeys = sshKeyNames

	responseBody.Networking = c.unqualifyNetworking(responseBody.Networking)

	return &responseBody, nil
}

type DeleteInstanceInput struct {
	// The Unqualified Name of this Instance
	Name string
	// The Unqualified ID of this Instance
	ID string
}

func (d *DeleteInstanceInput) String() string {
	return fmt.Sprintf(CMP_QUALIFIED_NAME, d.Name, d.ID)
}

// DeleteInstance deletes an instance.
func (c *InstancesClient) DeleteInstance(input *DeleteInstanceInput) error {
	// Call to delete the instance
	if err := c.deleteResource(input.String()); err != nil {
		return err
	}
	// Wait for instance to be deleted
	return c.WaitForInstanceDeleted(input, WaitForInstanceDeleteTimeout)
}

// WaitForInstanceRunning waits for an instance to be completely initialized and available.
func (c *InstancesClient) WaitForInstanceRunning(input *GetInstanceInput, timeoutSeconds int) (*InstanceInfo, error) {
	var info *InstanceInfo
	var getErr error
	err := c.waitFor("instance to be ready", timeoutSeconds, func() (bool, error) {
		info, getErr = c.GetInstance(input)
		if getErr != nil {
			return false, getErr
		}
		if info.State == "error" {
			return false, fmt.Errorf("Error initializing instance: %s", info.ErrorReason)
		}
		if info.State == "running" {
			return true, nil
		}
		return false, nil
	})
	return info, err
}

// WaitForInstanceDeleted waits for an instance to be fully deleted.
func (c *InstancesClient) WaitForInstanceDeleted(input *DeleteInstanceInput, timeoutSeconds int) error {
	return c.waitFor("instance to be deleted", timeoutSeconds, func() (bool, error) {
		var instanceInfo InstanceInfo
		if err := c.getResource(input.String(), &instanceInfo); err != nil {
			if WasNotFoundError(err) {
				return true, nil
			}
			return false, err
		}
		return false, nil
	})
}

func (c *InstancesClient) qualifyNetworking(info map[string]NetworkingInfo) map[string]NetworkingInfo {
	qualifiedNetworks := map[string]NetworkingInfo{}
	for k, v := range info {
		qfd := v
		sharedNetwork := false
		if v.IPNetwork != "" {
			// Network interface is for an IP Network
			qfd.IPNetwork = c.getQualifiedName(v.IPNetwork)
			sharedNetwork = true
		}
		if v.Vnic != "" {
			qfd.Vnic = c.getQualifiedName(v.Vnic)
		}
		if v.Nat != nil {
			qfd.Nat = c.qualifyNat(v.Nat, sharedNetwork)
		}
		if v.VnicSets != nil {
			qfd.VnicSets = c.qualifyVnicSet(v.VnicSets)
		}
		if v.SecLists != nil {
			// Network interface is for the shared network
			secLists := []string{}
			for _, v := range v.SecLists {
				secLists = append(secLists, c.getQualifiedName(v))
			}
			qfd.SecLists = secLists
		}

		qualifiedNetworks[k] = qfd
	}
	return qualifiedNetworks
}

func (c *InstancesClient) unqualifyNetworking(info map[string]NetworkingInfo) map[string]NetworkingInfo {
	// Unqualify ip network
	unqualifiedNetworks := map[string]NetworkingInfo{}
	for k, v := range info {
		unq := v
		if v.IPNetwork != "" {
			unq.IPNetwork = c.getUnqualifiedName(v.IPNetwork)
		}
		if v.Vnic != "" {
			unq.Vnic = c.getUnqualifiedName(v.Vnic)
		}
		if v.Nat != nil {
			unq.Nat = c.unqualifyNat(v.Nat)
		}
		if v.VnicSets != nil {
			unq.VnicSets = c.unqualifyVnicSet(v.VnicSets)
		}
		if v.SecLists != nil {
			secLists := []string{}
			for _, v := range v.SecLists {
				secLists = append(secLists, c.getUnqualifiedName(v))
			}
			v.SecLists = secLists
		}
		unqualifiedNetworks[k] = unq
	}
	return unqualifiedNetworks
}

func (c *InstancesClient) qualifyNat(nat []string, shared bool) []string {
	qualifiedNats := []string{}
	for _, v := range nat {
		if strings.HasPrefix(v, "ippool:/oracle") {
			qualifiedNats = append(qualifiedNats, v)
			continue
		}
		prefix := ReservationPrefix
		if shared {
			prefix = ReservationIPPrefix
		}
		qualifiedNats = append(qualifiedNats, fmt.Sprintf("%s:%s", prefix, c.getQualifiedName(v)))
	}
	return qualifiedNats
}

func (c *InstancesClient) unqualifyNat(nat []string) []string {
	return nat
	unQualifiedNats := []string{}
	for _, v := range nat {
		if strings.HasPrefix(v, "ippool:/oracle") {
			unQualifiedNats = append(unQualifiedNats, v)
			continue
		}
		n := strings.Split(v, ":")
		u := n[1]
		unQualifiedNats = append(unQualifiedNats, c.getUnqualifiedName(u))
	}
	return unQualifiedNats
}
